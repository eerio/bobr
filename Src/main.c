/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/
#include<stm32l0xx.h>

/* User LED: LD3 @ PB3 pin */
#define LED_PORT (GPIOB)
#define LED_PIN (3U)

#define LED_ON() (GPIOB->BSRR |= (1 << 3))
#define LED_OFF() (GPIOB->BRR |= (1 << 3))
#define LED_TOG() (GPIOB->ODR ^= (1 << 3))

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
/*
typedef struct Queue {
	uint8_t *buffer;
	unsigned int capacity;
	uint8_t *head;
	uint8_t *tail;
};
*/
volatile uint8_t rx_buffer[8];
volatile uint8_t tx_buffer[8];
const unsigned int rx_buffer_size=sizeof(rx_buffer) / sizeof(uint8_t);
const unsigned int tx_buffer_size=sizeof(rx_buffer) / sizeof(uint8_t);
//volatile uint8_t lpuart1_buf[1024]={0};
//volatile uint8_t lpuart1_count=0;
//volatile uint8_t lpuart1_buf_not_empty=0;

void delay(volatile unsigned n)
{
	while(--n);
}

void LPUART1_Init(void)
{
	/* TX: PA1 (AF6)
	 * RX: PA0 (AF6)
	 */
	RCC->IOPENR |= RCC_IOPENR_IOPAEN;
	GPIOA->MODER &= ~(GPIO_MODER_MODE0 | GPIO_MODER_MODE1);
	GPIOA->MODER |= GPIO_MODER_MODE0_1 | GPIO_MODER_MODE1_1;
    GPIOA->AFR[0] &= ~(GPIO_AFRL_AFSEL0 | GPIO_AFRL_AFSEL1);
    GPIOA->AFR[0] |= (0x6) << GPIO_AFRL_AFSEL0_Pos;
    GPIOA->AFR[0] |= (0x6) << GPIO_AFRL_AFSEL1_Pos;

	/* Configuration:
	 * Clock: HSI16 (1)
	 * Word: 1-8-1
	 * Baudrate: 1M
	 * No parity bits
	 * Mode: TX, RX
	 * Swap TX and RX
	 * No hardware control
	 */
    RCC->CR |= RCC_CR_HSION;
    while ((RCC->CR & RCC_CR_HSIRDY) == 0);
	RCC->CCIPR &= ~RCC_CCIPR_LPUART1SEL;  /* (1) */
	RCC->CCIPR |= RCC_CCIPR_LPUART1SEL_1;
	RCC->APB1ENR |= RCC_APB1ENR_LPUART1EN;

	// LPUART1->CR1 &= ~LPUART_CR1_M;
	LPUART1->CR2 |= USART_CR2_SWAP;
	LPUART1->CR3 |= USART_CR3_OVRDIS;
	uint32_t f_ck, baud;
	f_ck = 16000000; // SystemCoreClock;
	baud = 1000000;
	LPUART1->BRR |= 256 * f_ck / baud;
	//LPUART1->CR1 |= USART_CR1_RXNEIE;
	LPUART1->CR3 |= USART_CR3_DMAR;//USART_CR3_DMAT | USART_CR3_DMAR;
	LPUART1->CR1 |= USART_CR1_UE;
	LPUART1->CR1 |= USART_CR1_RE;
	LPUART1->CR1 |= USART_CR1_TE;

	/* Clear Framing Error and Character Match flags */
	LPUART1->ICR |= USART_ICR_FECF;
	/* Poll idle frame transmission */
	while ((LPUART1->ISR & USART_ISR_TC) == 0);
	/* Clear TC flag after idle frame transmission */
    LPUART1->ICR |= USART_ICR_TCCF;

    NVIC_EnableIRQ(LPUART1_IRQn);
    NVIC_SetPriority(LPUART1_IRQn, 0);
}

void DMA_Init(void)
{
	/* Errata: DMA channel 5 cannot be used for LPUART1 data reception
	 * Workaround: Use channel 3
	 */
	RCC->AHBENR |= RCC_AHBENR_DMA1EN;
	DMA1_CSELR->CSELR &= ~(DMA_CSELR_C2S | DMA_CSELR_C3S);
	DMA1_CSELR->CSELR |= ((0b0101 << DMA_CSELR_C2S_Pos) | (0b0101 << DMA_CSELR_C3S_Pos));

	/* Peripheral addresses: RDR / TDR registers of LPUART1 */
	DMA1_Channel2->CPAR = (uint32_t)(&LPUART1->TDR);
	DMA1_Channel3->CPAR = (uint32_t)(&LPUART1->RDR);
	/* Memory addresses: buffers */
	DMA1_Channel2->CMAR = (uint32_t)(tx_buffer);
	DMA1_Channel3->CMAR = (uint32_t)(rx_buffer);
	/* Not to cause a buffer overflow, set CNDTR to buffers' sizes */
	DMA1_Channel2->CNDTR |= (tx_buffer_size << DMA_CNDTR_NDT_Pos);
	DMA1_Channel3->CNDTR |= (rx_buffer_size << DMA_CNDTR_NDT_Pos);
	/* Increment memory address */
	DMA1_Channel2->CCR |= DMA_CCR_MINC;
	DMA1_Channel3->CCR |= DMA_CCR_MINC;
	/* Circular mode */
	DMA1_Channel2->CCR |= DMA_CCR_CIRC;
	DMA1_Channel3->CCR |= DMA_CCR_CIRC;
	/* Transfer direction: mem to periph for TX, periph to mem for RX */
	DMA1_Channel2->CCR |= DMA_CCR_DIR;
	DMA1_Channel3->CCR &= ~DMA_CCR_DIR;
	/* Enable channels */
	DMA1_Channel2->CCR |= DMA_CCR_EN;
	DMA1_Channel3->CCR |= DMA_CCR_EN;
}

void USART_Transmit(USART_TypeDef *USART, const uint8_t *buf, uint8_t count)
{
	for (int i=0; i < count; ++i)
	{
	    /* Wait till transmitter register's empty */
	    while ((USART->ISR & USART_ISR_TXE) == 0);
	    /* Write byte */
	    USART->TDR = buf[i];
	}
}

/*
void USART_Receive(USART_TypeDef *USART, uint8_t *buf, uint8_t count)
{
	for (int i=0; i < count; ++i)
	{
		// Wait till data received
		while ((USART->ISR & USART_ISR_RXNE) == 0);
		// Read byte
		buf[i] = USART->RDR;
	}
}
*/

void I2C1_Init(void)
{
	/* SCL: PB6 (AF1)
	 * SDA: PB7 (AF1)
	 */

	/* Sequence: RM p. 216 */
	RCC->IOPENR |= RCC_IOPENR_IOPBEN;
	GPIOB->MODER &= ~(GPIO_MODER_MODE6 | GPIO_MODER_MODE7);
	GPIOB->MODER |= GPIO_MODER_MODE6_1 | GPIO_MODER_MODE7_1;
    GPIOB->AFR[0] &= ~(GPIO_AFRL_AFSEL6 | GPIO_AFRL_AFSEL7);
    GPIOB->AFR[0] |= (0x1) << GPIO_AFRL_AFSEL6_Pos;
    GPIOB->AFR[0] |= (0x1) << GPIO_AFRL_AFSEL7_Pos;

    GPIOB->OTYPER |= GPIO_OTYPER_OT_6 | GPIO_OTYPER_OT_7;
    // GPIOB->PUPDR &= ~(GPIO_PUPDR_PUPDR6 | GPIO_PUPDR_PUPDR7);
    // GPIOB->PUPDR |= GPIO_PUPDR_PUPD6_0 | GPIO_PUPDR_PUPD7_0;

	/* Configuration:
	 * Mode: master
	 * Freq.: 100 kHz
	 * Source clock freq.: 16 MHz
	 * Filters: analog ON, digital OFF
	 * Rise time: 100ns
	 * Fall time: 10ns
	 * Addressing: 7 bit
	 *
	 * Source clock: HSI16
	 */
    RCC->CR |= RCC_CR_HSION;
    while ((RCC->CR & RCC_CR_HSIRDY) == 0)
    {
    	/* Add here timeout management */
    }

	RCC->CCIPR &= ~RCC_CCIPR_I2C1SEL;  /* (1) */
	RCC->CCIPR |= RCC_CCIPR_I2C1SEL_1;
	RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;

	/* Sequence: RM p. 590 */
	I2C1->TIMINGR |= 0x00503D5A;
	//I2C1->CR2 |= I2C_CR2_RELOAD;

	//I2C1->CR2 |= 0xA5;// << 1;

    //I2C1->OAR1 |= (uint32_t)(0x69 << 1);
    //I2C1->OAR1 |= I2C_OAR1_OA1EN;

	I2C1->CR1 |= I2C_CR1_PE;
}

void I2C_Master_Receive(
		I2C_TypeDef *I2C,
		uint8_t slave_addr,
		uint8_t *buf,
		uint8_t count
)
{
	/* Sequence: RM p. 611, 612 */
	I2C->CR2 = 0;
	while (I2C->ISR & I2C_ISR_BUSY);
	I2C->CR2 |= count << I2C_CR2_NBYTES_Pos;
	I2C->CR2 |= I2C_CR2_RD_WRN;
	I2C->CR2 |=  slave_addr << 1;
	I2C->CR2 |= I2C_CR2_START;
	for (int i=0; i < count; ++i)
	{
		while ((I2C->ISR & I2C_ISR_RXNE) == 0);
		*buf++ = I2C1->RXDR;
	}
	while ((I2C->ISR & I2C_ISR_TC) == 0);
	I2C->CR2 |= I2C_CR2_STOP;
	while (I2C->ISR & I2C_ISR_BUSY);
	I2C->ICR |= I2C_ICR_STOPCF;
}

void I2C_Master_Transmit(
		I2C_TypeDef *I2C,
		uint8_t slave_addr,
		const uint8_t *buf,
		uint8_t count
)
{
	// Sequence: RM p. 607, 608
	uint8_t addr = 0xEA >> 1;
	I2C1->CR2 = 0;
	while (I2C1->ISR & I2C_ISR_BUSY);
	I2C1->CR2 |= (count << I2C_CR2_NBYTES_Pos) | (addr << 1);
	I2C1->CR2 |= I2C_CR2_START;

	for (int i=0; i < count; ++i)
	{
		while ((I2C1->ISR & I2C_ISR_TXE) == 0);
		I2C1->TXDR = *buf++;
	}

	while ((I2C1->ISR & I2C_ISR_TC) == 0);
	I2C1->CR2 |= I2C_CR2_STOP;
	while (I2C1->ISR & I2C_ISR_BUSY);
	I2C1->ICR |= I2C_ICR_STOPCF;
}

void ADC_config(void)
{
	RCC->IOPENR |= RCC_IOPENR_IOPAEN;
	GPIOA->MODER |= GPIO_MODER_MODE0;

	RCC->APB2ENR |= RCC_APB2ENR_ADCEN;
	ADC1->CHSELR |= ADC_CHSELR_CHSEL0;

	ADC1->CFGR1 |= ADC_CFGR1_CONT;
	ADC1->CFGR1 |= ADC_CFGR1_OVRMOD;
	//ADC1->CR |= ADC_CR_ADEN;
	//while ((ADC1->ISR & ADC_ISR_ADRDY) == 0) {}
	ADC1->CR |= ADC_CR_ADCAL;
	while (ADC1->CR & ADC_CR_ADCAL);

	ADC1->CR |= ADC_CR_ADEN;
	if (ADC1->ISR & ADC_ISR_ADRDY) {
	    ADC1->ISR |= ADC_ISR_ADRDY;
	}
    ADC1->CR |= ADC_CR_ADSTART;
    ADC->CCR |= ADC_CCR_VREFEN;
    while ((ADC1->ISR & ADC_ISR_ADRDY) == 0) {}
}


void USART_Receive (
		USART_TypeDef *USART,
		uint8_t *is_empty_flag,
		uint8_t *dest,
		uint8_t *src,
		uint8_t count)
{


}

void I2C1_IRQHandler(void)
{
	if (I2C1->ISR & I2C_ISR_RXNE)
	{

	}
}

int main(void)
{
	RCC->IOPENR |= RCC_IOPENR_IOPBEN;
	GPIOB->MODER &= ~(GPIO_MODER_MODE3);
	GPIOB->MODER |= GPIO_MODER_MODE3_0;

	LPUART1_Init();
	I2C1_Init();
	DMA_Init();

	uint8_t buf[8] = "chujnia";
	uint8_t slave = 0x75;

	while (1)
	{
		USART_Transmit(LPUART1, buf, 8);
		while (rx_buffer[0] != 'C');
		//LED_ON();
		//delay(50000);
		//USART_Receive(LPUART1, buf, 8);
		//LED_OFF();
		//while((LPUART1->ISR & USART_ISR_TC));
		//while((LPUART1->ISR & USART_ISR_TC) == 0);
		//delay(15000);
		I2C_Master_Transmit(I2C1, slave, rx_buffer, 8);
		I2C_Master_Receive(I2C1, slave, buf, 8);

		LED_ON();
		delay(50000);
		LED_OFF();
		delay(50000);
	}
}

void LPUART1_IRQHandler(void)
{
	LED_ON();
	while(1);
}
